<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>SOLUTIONS – Quantum Computing with Qiskit — 6.2410 -- Laboratory for Quantum Information Science and Engineering</title>
<link href="_static/css/theme.css" rel="stylesheet"/>
<link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet"/>
<link href="_static/vendor/fontawesome/5.13.0/css/all.min.css" rel="stylesheet"/>
<link as="font" crossorigin="" href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2" rel="preload" type="font/woff2"/>
<link as="font" crossorigin="" href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2" rel="preload" type="font/woff2"/>
<link href="_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" rel="stylesheet" type="text/css"/>
<link href="_static/togglebutton.css" rel="stylesheet" type="text/css"/>
<link href="_static/copybutton.css" rel="stylesheet" type="text/css"/>
<link href="_static/mystnb.css" rel="stylesheet" type="text/css"/>
<link href="_static/sphinx-thebe.css" rel="stylesheet" type="text/css"/>
<link href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" rel="stylesheet" type="text/css"/>
<link href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" rel="stylesheet" type="text/css"/>
<link as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js" rel="preload"/>
<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
<script src="_static/jquery.js"></script>
<script src="_static/underscore.js"></script>
<script src="_static/doctools.js"></script>
<script src="_static/clipboard.min.js"></script>
<script src="_static/copybutton.js"></script>
<script>let toggleHintShow = 'Click to show';</script>
<script>let toggleHintHide = 'Click to hide';</script>
<script>let toggleOpenOnPrint = 'true';</script>
<script src="_static/togglebutton.js"></script>
<script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
<script src="_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
<script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
<script async="async" src="_static/sphinx-thebe.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
<script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
<script>window.MathJax = {"tex": {"macros": {"ket": ["\\left|{#1}\\right\\rangle", 1], "bra": ["\\left\\langle{#1}\\right|", 1], "braket": ["\\left\\langle{#1}\\middle|{#2}\\right\\rangle", 2], "adagger": ["\\hat{a}^{\\dagger}"], "ahat": ["\\hat{a}"], "bdagger": ["\\hat{b}^{\\dagger}"], "bhat": ["\\hat{b}"], "cdagger": ["\\hat{c}^{\\dagger}"], "chat": ["\\hat{c}"], "ddagger": ["\\hat{d}^{\\dagger}"], "dhat": ["\\hat{d}"], "edagger": ["\\hat{e}^{\\dagger}"], "ehat": ["\\hat{e}"], "fdagger": ["\\hat{f}^{\\dagger}"], "fhat": ["\\hat{f}"], "gdagger": ["\\hat{g}^{\\dagger}"], "ghat": ["\\hat{g}"], "hdagger": ["\\hat{h}^{\\dagger}"], "hhat": ["\\hat{h}"], "gtwo": ["g^{(2)}"], "H": ["\\ket{H}"], "V": ["\\ket{V}"], "D": ["\\ket{D}"], "AD": ["\\ket{AD}"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
<script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link href="genindex.html" rel="index" title="Index"/>
<link href="search.html" rel="search" title="Search"/>
<link href="FINAL-PROJECTS.html" rel="next" title="Final Design Project"/>
<link href="T1E2-LAB-IBM-Qiskit.html" rel="prev" title="LAB – Quantum Computing w/ Qiskit"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="None" name="docsearch:language"/>
<!-- Google Analytics -->
<link href="_static/css/chattutor.css" rel="stylesheet" type="text/css"/></head>
<body data-offset="80" data-spy="scroll" data-target="#bd-toc-nav">
<div class="container-fluid" id="banner"></div>
<div class="container-xl">
<div class="row">
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
<div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="index.html">
<!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
<img alt="logo" class="logo" src="_static/logo-ibm.jpg"/>
<h1 class="site-logo" id="site-title">6.2410 -- Laboratory for Quantum Information Science and Engineering</h1>
</a>
</div><form action="search.html" class="bd-search d-flex align-items-center" method="get">
<i class="icon fas fa-search"></i>
<input aria-label="Search this book..." autocomplete="off" class="form-control" id="search-input" name="q" placeholder="Search this book..." type="search"/>
</form><nav aria-label="Main" class="bd-links" id="bd-docs-nav">
<div class="bd-toc-item active">
<ul class="nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="intro.html">
   6.2410 – Laboratory in Quantum Systems Engineering: Quantum Engineering Platforms
  </a>
</li>
</ul>
<p aria-level="2" class="caption" role="heading">
<span class="caption-text">
  Introductory Material
 </span>
</p>
<ul class="nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="BASICS-quantum-optics-basics.html">
   BASICS – Quantum Optics
  </a>
</li>
</ul>
<p aria-level="2" class="caption" role="heading">
<span class="caption-text">
  T3E1 -- Interference, Entanglement, Quantum-Enhanced Sensing
 </span>
</p>
<ul class="nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="T3E1-TEXT--entanglement-interference-quantum-enhanced-sensing.html">
   TEXT – Interference, Entanglement and Quantum-Enhanced Metrology
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="T3E1-LAB--entanglement-interference-quantum-enhanced-sensing.html">
   LAB – Interference, Entanglement and Quantum-Enhanced Metrology
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="T3E1-EXTRAS--rigorous-solution-MZI.html">
   EXTRAS – Rigorous Solution of Mach-Zender Interferometer
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="T3E1-EXTRAS-interference-2-homodyne-detection.html">
   EXTRAS – Homodyne Detection
  </a>
</li>
</ul>
<p aria-level="2" class="caption" role="heading">
<span class="caption-text">
  T2E1 -- Quantum Information and Quantum Key Distribution
 </span>
</p>
<ul class="nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="T2E1-TEXT-HBT.html">
   TEXT - Introduction to single photons with the quED (Week 1)
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="T2E1-LAB-HBT.html">
   LAB – Hanbury Brown - Twiss Lab (Week 1)
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="T2E1-TEXT-QKD.html">
   TEXT – QKD (Week 2)
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="T2E1-LAB-BB84.html">
   LAB – QKD (Week 2)
  </a>
</li>
</ul>
<p aria-level="2" class="caption" role="heading">
<span class="caption-text">
  T3E3 -- Solid State Spins
 </span>
</p>
<ul class="nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="quNV-Jupyter/T3E3-PARKOUR-Quantum-Sensing-with-Solid-State-Spins.html">
   TRAINING - Interfacing with the Vector Network Analyzer
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="quNV-Jupyter/T3E3-TEXT-Quantum-Sensing-with-Solid-State-Spins.html">
   TEXT: Introduction to NV centers in diamond and cavity-based magnetometry
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="quNV-Jupyter/T3E3-LAB-Week1-Quantum-Sensing-with-Solid-State-Spins.html">
   LAB - Quantum Sensing with Solid State Spins (Week 1)
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="quNV-Jupyter/T3E3-LAB-Week2-Quantum-Sensing-with-Solid-State-Spins.html">
   LAB – Quantum Sensing With Solid State Spins (Week 2)
  </a>
</li>
</ul>
<p aria-level="2" class="caption" role="heading">
<span class="caption-text">
  T1E2 -- Quantum Computing w/ IBM Qiskit (OPTIONAL)
 </span>
</p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="T1E2-LAB-IBM-Qiskit-Prelab.html">
   PRELAB –Intro to IBM Qiskit
  </a>
</li>
<li class="toctree-l1">
<a class="reference internal" href="T1E2-LAB-IBM-Qiskit.html">
   LAB – Quantum Computing w/ Qiskit
  </a>
</li>
<li class="toctree-l1 current active">
<a class="current reference internal" href="#">
   SOLUTIONS – Quantum Computing with Qiskit
  </a>
</li>
</ul>
<p aria-level="2" class="caption" role="heading">
<span class="caption-text">
  Final Projects
 </span>
</p>
<ul class="nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="FINAL-PROJECTS.html">
   Final Design Project
  </a>
</li>
</ul>
<p aria-level="2" class="caption" role="heading">
<span class="caption-text">
  Other Resources
 </span>
</p>
<ul class="nav bd-sidenav">
<li class="toctree-l1">
<a class="reference internal" href="OTHER-quantum-monte-carlo-simulation-spin-entanglement-repeaters.html">
   Entanglement Distribution by Quantum Repeaters: Exploration by Quantum Monte Carlo Simulation
  </a>
</li>
</ul>
</div>
</nav> <!-- To handle the deprecated key -->
<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>
</div>
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
<div class="topbar container-xl fixed-top">
<div class="topbar-contents row">
<div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
<div class="col pl-md-4 topbar-main">
<button aria-controls="navbar-menu" aria-expanded="true" aria-label="Toggle navigation" class="navbar-toggler ml-0" data-placement="bottom" data-target=".site-navigation" data-toggle="collapse" id="navbar-toggler" title="Toggle navigation" type="button">
<i class="fas fa-bars"></i>
<i class="fas fa-arrow-left"></i>
<i class="fas fa-arrow-up"></i>
</button>
<div class="dropdown-buttons-trigger">
<button aria-label="Download this page" class="btn btn-secondary topbarbtn" id="dropdown-buttons-trigger"><i class="fas fa-download"></i></button>
<div class="dropdown-buttons">
<!-- ipynb file if we had a myst markdown file -->
<!-- Download raw file -->
<a class="dropdown-buttons" href="_sources/T1E2-LAB-IBM-Qiskit-Solutions.ipynb"><button class="btn btn-secondary topbarbtn" data-placement="left" data-toggle="tooltip" title="Download source file" type="button">.ipynb</button></a>
<!-- Download PDF via print -->
<button class="btn btn-secondary topbarbtn" data-placement="left" data-toggle="tooltip" id="download-print" onclick="printPdf(this)" title="Print to PDF" type="button">.pdf</button>
</div>
</div>
<!-- Source interaction buttons -->
<div class="dropdown-buttons-trigger">
<button aria-label="Connect with source repository" class="btn btn-secondary topbarbtn" id="dropdown-buttons-trigger"><i class="fab fa-github"></i></button>
<div class="dropdown-buttons sourcebuttons">
<a class="repository-button" href="https://github.com/dkeathley/S23-6.2410-lab"><button class="btn btn-secondary topbarbtn" data-placement="left" data-toggle="tooltip" title="Source repository" type="button"><i class="fab fa-github"></i>repository</button></a>
<a class="issues-button" href="https://github.com/dkeathley/S23-6.2410-lab/issues/new?title=Issue%20on%20page%20%2FT1E2-LAB-IBM-Qiskit-Solutions.html&amp;body=Your%20issue%20content%20here."><button class="btn btn-secondary topbarbtn" data-placement="left" data-toggle="tooltip" title="Open an issue" type="button"><i class="fas fa-lightbulb"></i>open issue</button></a>
</div>
</div>
<!-- Full screen (wrap in <a> to have style consistency -->
<a class="full-screen-button"><button aria-label="Fullscreen mode" class="btn btn-secondary topbarbtn" data-placement="bottom" data-toggle="tooltip" onclick="toggleFullScreen()" title="Fullscreen mode" type="button"><i class="fas fa-expand"></i></button></a>
<!-- Launch buttons -->
<div class="dropdown-buttons-trigger">
<button aria-label="Launch interactive content" class="btn btn-secondary topbarbtn" id="dropdown-buttons-trigger"><i class="fas fa-rocket"></i></button>
<div class="dropdown-buttons">
<a class="binder-button" href="https://mybinder.org/v2/gh/dkeathley/S23-6.2410-lab/main?urlpath=tree/T1E2-LAB-IBM-Qiskit-Solutions.ipynb"><button class="btn btn-secondary topbarbtn" data-placement="left" data-toggle="tooltip" title="Launch Binder" type="button"><img alt="Interact on binder" class="binder-button-logo" src="_static/images/logo_binder.svg"/>Binder</button></a>
<a class="colab-button" href="https://colab.research.google.com/github/dkeathley/S23-6.2410-lab/blob/main/T1E2-LAB-IBM-Qiskit-Solutions.ipynb"><button class="btn btn-secondary topbarbtn" data-placement="left" data-toggle="tooltip" title="Launch Colab" type="button"><img alt="Interact on Colab" class="colab-button-logo" src="_static/images/logo_colab.png"/>Colab</button></a>
</div>
</div>
</div>
<!-- Table of contents -->
<div class="d-none d-md-block col-md-2 bd-toc show noprint">
<div class="tocsection onthispage pt-5 pb-3">
<i class="fas fa-list"></i> Contents
            </div>
<nav aria-label="Page" id="bd-toc-nav">
<ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-1-quantum-circuits">
   Part 1: Quantum Circuits
  </a>
<ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#xor-gate">
     XOR gate
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#and-gate">
     AND gate
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#nand-gate">
     NAND gate
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#or-gate">
     OR gate
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-2-quantum-measurements">
   Part 2 Quantum Measurements
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#measuring-energy">
   Measuring Energy
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#quantum-teleportation">
   Quantum teleportation
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-3-accuracy-of-quantum-phase-estimation">
   Part 3 Accuracy of Quantum Phase Estimation
  </a>
<ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#performance-of-quantum-phase-estimation">
     Performance of Quantum Phase Estimation
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-4-quantum-error-correction">
   Part 4 Quantum Error Correction
  </a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="row" id="main-content">
<div class="col-12 col-md-9 pl-md-3 pr-md-0">
<!-- Table of contents that is only displayed when printing the page -->
<div class="onlyprint" id="jb-print-docs-body">
<h1>SOLUTIONS – Quantum Computing with Qiskit</h1>
<!-- Table of contents -->
<div id="print-main-content">
<div id="jb-print-toc">
<div>
<h2> Contents </h2>
</div>
<nav aria-label="Page">
<ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-1-quantum-circuits">
   Part 1: Quantum Circuits
  </a>
<ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#xor-gate">
     XOR gate
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#and-gate">
     AND gate
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#nand-gate">
     NAND gate
    </a>
</li>
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#or-gate">
     OR gate
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-2-quantum-measurements">
   Part 2 Quantum Measurements
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#measuring-energy">
   Measuring Energy
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#quantum-teleportation">
   Quantum teleportation
  </a>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-3-accuracy-of-quantum-phase-estimation">
   Part 3 Accuracy of Quantum Phase Estimation
  </a>
<ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry">
<a class="reference internal nav-link" href="#performance-of-quantum-phase-estimation">
     Performance of Quantum Phase Estimation
    </a>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry">
<a class="reference internal nav-link" href="#part-4-quantum-error-correction">
   Part 4 Quantum Error Correction
  </a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div>
<p>*The following Qiskit exercises were selected and adapted from the official IBM Qiskit textbook.</p>
<div class="tex2jax_ignore mathjax_ignore section" id="solutions-quantum-computing-with-qiskit">
<h1>SOLUTIONS – Quantum Computing with Qiskit<a class="headerlink" href="#solutions-quantum-computing-with-qiskit" title="Permalink to this headline">¶</a></h1>
<div class="section" id="part-1-quantum-circuits">
<h2>Part 1: Quantum Circuits<a class="headerlink" href="#part-1-quantum-circuits" title="Permalink to this headline">¶</a></h2>
<p>Prerequisite</p>
<ul class="simple">
<li><p><a class="reference external" href="https://qiskit.org/documentation/tutorials/circuits/1_getting_started_with_qiskit.html">Qiskit basics</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-states/atoms-computation.html">Ch.1.2 The Atoms of Computation</a></p></li>
</ul>
<p>Other relevant materials</p>
<ul class="simple">
<li><p><a class="reference external" href="https://qiskit.org/documentation/install.html#access-ibm-quantum-systems">Access IBM Quantum Systems</a></p></li>
<li><p><a class="reference external" href="https://quantum-computing.ibm.com/docs/manage/backends/configuration">IBM Quantum Systems Configuration</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/documentation/apidoc/transpiler.html">Transpile</a></p></li>
<li><p><a class="reference external" href="https://quantum-computing.ibm.com/docs/manage/account/ibmq">IBM Quantum account</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/documentation/apidoc/circuit.html">Quantum Circuits</a></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ModuleNotFoundError</span><span class="g g-Whitespace">                       </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">line</span> <span class="mi">1</span>
<span class="ne">----&gt; </span><span class="mi">1</span> <span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="o">*</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="ne">ModuleNotFoundError</span>: No module named 'qiskit'
</pre></div>
</div>
</div>
</div>
<h2 style="font-size:24px;">Classical logic gates with quantum circuits</h2>
<br/>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
<p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
<p style=" padding: 0px 0px 10px 10px;
              font-size:16px;">Create quantum circuit functions that can compute the XOR, AND, NAND and OR gates using the NOT gate (expressed as x in Qiskit), the CNOT gate (expressed as cx in Qiskit) and the Toffoli gate (expressed as ccx in Qiskit) .</p>
</div>
<p>An implementation of the <code class="docutils literal notranslate"><span class="pre">NOT</span></code> gate is provided as an example.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">NOT</span><span class="p">(</span><span class="n">inp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""An NOT gate.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        inp (str): Input, encoded in qubit 0.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        QuantumCircuit: Output NOT circuit.</span>
<span class="sd">        str: Output value measured from qubit 0.</span>
<span class="sd">    """</span>

    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># A quantum circuit with a single qubit and a single classical bit</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># We encode '0' as the qubit state |0⟩, and '1' as |1⟩</span>
    <span class="c1"># Since the qubit is initially |0⟩, we don't need to do anything for an input of '0'</span>
    <span class="c1"># For an input of '1', we do an x to rotate the |0⟩ to |1⟩</span>
    <span class="k">if</span> <span class="n">inp</span><span class="o">==</span><span class="s1">'1'</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        
    <span class="c1"># barrier between input state and gate operation </span>
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    
    <span class="c1"># Now we've encoded the input, we can do a NOT on it using x</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1">#barrier between gate operation and measurement</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    
    <span class="c1"># Finally, we extract the |0⟩/|1⟩ output of the qubit and encode it in the bit c[0]</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">'mpl'</span><span class="p">)</span>
    
    <span class="c1"># We'll run the program on a simulator</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">'aer_simulator'</span><span class="p">)</span>
    <span class="c1"># Since the output will be deterministic, we can use just a single shot to get it</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">qc</span><span class="p">,</span> <span class="n">output</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Test the function</span>
<span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">]:</span>
    <span class="n">qc</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">NOT</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'NOT with input'</span><span class="p">,</span><span class="n">inp</span><span class="p">,</span><span class="s1">'gives output'</span><span class="p">,</span><span class="n">out</span><span class="p">)</span>
    <span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>NOT with input 0 gives output 1
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>           ░ ┌───┐ ░ ┌─┐
  q: ─|0&gt;──░─┤ X ├─░─┤M├
           ░ └───┘ ░ └╥┘
c: 1/═════════════════╩═
                      0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>NOT with input 1 gives output 0
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>          ┌───┐ ░ ┌───┐ ░ ┌─┐
  q: ─|0&gt;─┤ X ├─░─┤ X ├─░─┤M├
          └───┘ ░ └───┘ ░ └╥┘
c: 1/══════════════════════╩═
                           0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="xor-gate">
<h3>XOR gate<a class="headerlink" href="#xor-gate" title="Permalink to this headline">¶</a></h3>
<p>Takes two binary strings as input and gives one as output.</p>
<p>The output is ‘0’ when the inputs are equal and  ‘1’ otherwise.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">XOR</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""An XOR gate.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        inpt1 (str): Input 1, encoded in qubit 0.</span>
<span class="sd">        inpt2 (str): Input 2, encoded in qubit 1.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        QuantumCircuit: Output XOR circuit.</span>
<span class="sd">        str: Output value measured from qubit 1.</span>
<span class="sd">    """</span>
  
    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">qc</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">inp1</span><span class="o">==</span><span class="s1">'1'</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inp2</span><span class="o">==</span><span class="s1">'1'</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># barrier between input state and gate operation </span>
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    
    <span class="c1"># this is where your program for quantum XOR gate goes</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    
    
    
    <span class="c1"># barrier between input state and gate operation </span>
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    
    <span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># output from qubit 1 is measured</span>
  
    <span class="c1">#We'll run the program on a simulator</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">'aer_simulator'</span><span class="p">)</span>
    <span class="c1">#Since the output will be deterministic, we can use just a single shot to get it</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
  
    <span class="k">return</span> <span class="n">qc</span><span class="p">,</span> <span class="n">output</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Test the function</span>
<span class="k">for</span> <span class="n">inp1</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">inp2</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">]:</span>
        <span class="n">qc</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">XOR</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span> <span class="n">inp2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'XOR with inputs'</span><span class="p">,</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">,</span><span class="s1">'gives output'</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>XOR with inputs 0 0 gives output 0
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>           ░       ░    
q_0: ─|0&gt;──░───■───░────
           ░ ┌─┴─┐ ░ ┌─┐
q_1: ─|0&gt;──░─┤ X ├─░─┤M├
           ░ └───┘ ░ └╥┘
c: 1/═════════════════╩═
                      0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>XOR with inputs 0 1 gives output 1
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>                ░       ░    
q_0: ─|0&gt;───────░───■───░────
          ┌───┐ ░ ┌─┴─┐ ░ ┌─┐
q_1: ─|0&gt;─┤ X ├─░─┤ X ├─░─┤M├
          └───┘ ░ └───┘ ░ └╥┘
c: 1/══════════════════════╩═
                           0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>XOR with inputs 1 0 gives output 1
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>          ┌───┐ ░       ░    
q_0: ─|0&gt;─┤ X ├─░───■───░────
          └───┘ ░ ┌─┴─┐ ░ ┌─┐
q_1: ─|0&gt;───────░─┤ X ├─░─┤M├
                ░ └───┘ ░ └╥┘
c: 1/══════════════════════╩═
                           0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>XOR with inputs 1 1 gives output 0
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>          ┌───┐ ░       ░    
q_0: ─|0&gt;─┤ X ├─░───■───░────
          ├───┤ ░ ┌─┴─┐ ░ ┌─┐
q_1: ─|0&gt;─┤ X ├─░─┤ X ├─░─┤M├
          └───┘ ░ └───┘ ░ └╥┘
c: 1/══════════════════════╩═
                           0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="and-gate">
<h3>AND gate<a class="headerlink" href="#and-gate" title="Permalink to this headline">¶</a></h3>
<p>Takes two binary strings as input and gives one as output.</p>
<p>The output is <code class="docutils literal notranslate"><span class="pre">'1'</span></code> only when both the inputs are <code class="docutils literal notranslate"><span class="pre">'1'</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">AND</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""An AND gate.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        inpt1 (str): Input 1, encoded in qubit 0.</span>
<span class="sd">        inpt2 (str): Input 2, encoded in qubit 1.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        QuantumCircuit: Output AND circuit.</span>
<span class="sd">        str: Output value measured from qubit 2.</span>
<span class="sd">    """</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">qc</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
  
    <span class="k">if</span> <span class="n">inp1</span><span class="o">==</span><span class="s1">'1'</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inp2</span><span class="o">==</span><span class="s1">'1'</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

    <span class="c1"># this is where your program for quantum AND gate goes</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    
    
    
    
    

    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># output from qubit 2 is measured</span>
  
    <span class="c1"># We'll run the program on a simulator</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">'aer_simulator'</span><span class="p">)</span>
    <span class="c1"># Since the output will be deterministic, we can use just a single shot to get it</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
  
    <span class="k">return</span> <span class="n">qc</span><span class="p">,</span> <span class="n">output</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Test the function</span>
<span class="k">for</span> <span class="n">inp1</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">inp2</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">]:</span>
        <span class="n">qc</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">AND</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span> <span class="n">inp2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'AND with inputs'</span><span class="p">,</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">,</span><span class="s1">'gives output'</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>AND with inputs 0 0 gives output 0
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>           ░       ░    
q_0: ─|0&gt;──░───■───░────
           ░   │   ░    
q_1: ─|0&gt;──░───■───░────
           ░ ┌─┴─┐ ░ ┌─┐
q_2: ──────░─┤ X ├─░─┤M├
           ░ └───┘ ░ └╥┘
c: 1/═════════════════╩═
                      0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>AND with inputs 0 1 gives output 0
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>                ░       ░    
q_0: ─|0&gt;───────░───■───░────
          ┌───┐ ░   │   ░    
q_1: ─|0&gt;─┤ X ├─░───■───░────
          └───┘ ░ ┌─┴─┐ ░ ┌─┐
q_2: ───────────░─┤ X ├─░─┤M├
                ░ └───┘ ░ └╥┘
c: 1/══════════════════════╩═
                           0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>AND with inputs 1 0 gives output 0
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>          ┌───┐ ░       ░    
q_0: ─|0&gt;─┤ X ├─░───■───░────
          └───┘ ░   │   ░    
q_1: ─|0&gt;───────░───■───░────
                ░ ┌─┴─┐ ░ ┌─┐
q_2: ───────────░─┤ X ├─░─┤M├
                ░ └───┘ ░ └╥┘
c: 1/══════════════════════╩═
                           0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>AND with inputs 1 1 gives output 1
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>          ┌───┐ ░       ░    
q_0: ─|0&gt;─┤ X ├─░───■───░────
          ├───┤ ░   │   ░    
q_1: ─|0&gt;─┤ X ├─░───■───░────
          └───┘ ░ ┌─┴─┐ ░ ┌─┐
q_2: ───────────░─┤ X ├─░─┤M├
                ░ └───┘ ░ └╥┘
c: 1/══════════════════════╩═
                           0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="nand-gate">
<h3>NAND gate<a class="headerlink" href="#nand-gate" title="Permalink to this headline">¶</a></h3>
<p>Takes two binary strings as input and gives one as output.</p>
<p>The output is <code class="docutils literal notranslate"><span class="pre">'0'</span></code> only when both the inputs are <code class="docutils literal notranslate"><span class="pre">'1'</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">NAND</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""An NAND gate.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        inpt1 (str): Input 1, encoded in qubit 0.</span>
<span class="sd">        inpt2 (str): Input 2, encoded in qubit 1.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        QuantumCircuit: Output NAND circuit.</span>
<span class="sd">        str: Output value measured from qubit 2.</span>
<span class="sd">    """</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">qc</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">inp1</span><span class="o">==</span><span class="s1">'1'</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inp2</span><span class="o">==</span><span class="s1">'1'</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    
    <span class="c1"># this is where your program for quantum NAND gate goes</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    
    
    
    
    
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># output from qubit 2 is measured</span>
  
    <span class="c1"># We'll run the program on a simulator</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">'aer_simulator'</span><span class="p">)</span>
    <span class="c1"># Since the output will be deterministic, we can use just a single shot to get it</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span><span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
  
    <span class="k">return</span> <span class="n">qc</span><span class="p">,</span> <span class="n">output</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Test the function</span>
<span class="k">for</span> <span class="n">inp1</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">inp2</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">]:</span>
        <span class="n">qc</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">NAND</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span> <span class="n">inp2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'NAND with inputs'</span><span class="p">,</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">,</span><span class="s1">'gives output'</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>NAND with inputs 0 0 gives output 1
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>           ░            ░    
q_0: ─|0&gt;──░───■────────░────
           ░   │        ░    
q_1: ─|0&gt;──░───■────────░────
           ░ ┌─┴─┐┌───┐ ░ ┌─┐
q_2: ─|0&gt;──░─┤ X ├┤ X ├─░─┤M├
           ░ └───┘└───┘ ░ └╥┘
c: 1/══════════════════════╩═
                           0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>NAND with inputs 0 1 gives output 1
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>                ░            ░    
q_0: ─|0&gt;───────░───■────────░────
          ┌───┐ ░   │        ░    
q_1: ─|0&gt;─┤ X ├─░───■────────░────
          └───┘ ░ ┌─┴─┐┌───┐ ░ ┌─┐
q_2: ─|0&gt;───────░─┤ X ├┤ X ├─░─┤M├
                ░ └───┘└───┘ ░ └╥┘
c: 1/═══════════════════════════╩═
                                0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>NAND with inputs 1 0 gives output 1
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>          ┌───┐ ░            ░    
q_0: ─|0&gt;─┤ X ├─░───■────────░────
          └───┘ ░   │        ░    
q_1: ─|0&gt;───────░───■────────░────
                ░ ┌─┴─┐┌───┐ ░ ┌─┐
q_2: ─|0&gt;───────░─┤ X ├┤ X ├─░─┤M├
                ░ └───┘└───┘ ░ └╥┘
c: 1/═══════════════════════════╩═
                                0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>NAND with inputs 1 1 gives output 0
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>          ┌───┐ ░            ░    
q_0: ─|0&gt;─┤ X ├─░───■────────░────
          ├───┤ ░   │        ░    
q_1: ─|0&gt;─┤ X ├─░───■────────░────
          └───┘ ░ ┌─┴─┐┌───┐ ░ ┌─┐
q_2: ─|0&gt;───────░─┤ X ├┤ X ├─░─┤M├
                ░ └───┘└───┘ ░ └╥┘
c: 1/═══════════════════════════╩═
                                0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="or-gate">
<h3>OR gate<a class="headerlink" href="#or-gate" title="Permalink to this headline">¶</a></h3>
<p>Takes two binary strings as input and gives one as output.</p>
<p>The output is ‘1’ if either input is ‘1’.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">OR</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""An OR gate.</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">        inpt1 (str): Input 1, encoded in qubit 0.</span>
<span class="sd">        inpt2 (str): Input 2, encoded in qubit 1.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        QuantumCircuit: Output XOR circuit.</span>
<span class="sd">        str: Output value measured from qubit 2.</span>
<span class="sd">    """</span>

    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
    <span class="n">qc</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">inp1</span><span class="o">==</span><span class="s1">'1'</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inp2</span><span class="o">==</span><span class="s1">'1'</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
   
    <span class="c1"># this is where your program for quantum OR gate goes</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">ccx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

    
    
    
    
    
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># output from qubit 2 is measured</span>
  
    <span class="c1"># We'll run the program on a simulator</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">'aer_simulator'</span><span class="p">)</span>
    <span class="c1"># Since the output will be deterministic, we can use just a single shot to get it</span>
    <span class="n">job</span> <span class="o">=</span> <span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span><span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">job</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    
    
  
    <span class="k">return</span> <span class="n">qc</span><span class="p">,</span> <span class="n">output</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Test the function</span>
<span class="k">for</span> <span class="n">inp1</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">inp2</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">]:</span>
        <span class="n">qc</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="n">OR</span><span class="p">(</span><span class="n">inp1</span><span class="p">,</span> <span class="n">inp2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'OR with inputs'</span><span class="p">,</span><span class="n">inp1</span><span class="p">,</span><span class="n">inp2</span><span class="p">,</span><span class="s1">'gives output'</span><span class="p">,</span><span class="n">output</span><span class="p">)</span>
        <span class="n">display</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">())</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>OR with inputs 0 0 gives output 0
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>           ░                 ░    
q_0: ─|0&gt;──░───■────■────────░────
           ░   │  ┌─┴─┐      ░    
q_1: ─|0&gt;──░───■──┤ X ├──■───░────
           ░ ┌─┴─┐└───┘┌─┴─┐ ░ ┌─┐
q_2: ─|0&gt;──░─┤ X ├─────┤ X ├─░─┤M├
           ░ └───┘     └───┘ ░ └╥┘
c: 1/═══════════════════════════╩═
                                0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>OR with inputs 0 1 gives output 1
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>                ░                 ░    
q_0: ─|0&gt;───────░───■────■────────░────
          ┌───┐ ░   │  ┌─┴─┐      ░    
q_1: ─|0&gt;─┤ X ├─░───■──┤ X ├──■───░────
          └───┘ ░ ┌─┴─┐└───┘┌─┴─┐ ░ ┌─┐
q_2: ─|0&gt;───────░─┤ X ├─────┤ X ├─░─┤M├
                ░ └───┘     └───┘ ░ └╥┘
c: 1/════════════════════════════════╩═
                                     0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>OR with inputs 1 0 gives output 1
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>          ┌───┐ ░                 ░    
q_0: ─|0&gt;─┤ X ├─░───■────■────────░────
          └───┘ ░   │  ┌─┴─┐      ░    
q_1: ─|0&gt;───────░───■──┤ X ├──■───░────
                ░ ┌─┴─┐└───┘┌─┴─┐ ░ ┌─┐
q_2: ─|0&gt;───────░─┤ X ├─────┤ X ├─░─┤M├
                ░ └───┘     └───┘ ░ └╥┘
c: 1/════════════════════════════════╩═
                                     0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>OR with inputs 1 1 gives output 1
</pre></div>
</div>
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>          ┌───┐ ░                 ░    
q_0: ─|0&gt;─┤ X ├─░───■────■────────░────
          ├───┤ ░   │  ┌─┴─┐      ░    
q_1: ─|0&gt;─┤ X ├─░───■──┤ X ├──■───░────
          └───┘ ░ ┌─┴─┐└───┘┌─┴─┐ ░ ┌─┐
q_2: ─|0&gt;───────░─┤ X ├─────┤ X ├─░─┤M├
                ░ └───┘     └───┘ ░ └╥┘
c: 1/════════════════════════════════╩═
                                     0 </pre></div><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="part-2-quantum-measurements">
<h2>Part 2 Quantum Measurements<a class="headerlink" href="#part-2-quantum-measurements" title="Permalink to this headline">¶</a></h2>
<p>Prerequisite</p>
<ul class="simple">
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-states/single-qubit-gates.html">Ch.1.4 Single Qubit Gates</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-gates/multiple-qubits-entangled-states.html">Ch.2.2 Multiple Qubits and Entangled States</a></p></li>
<li><p><a class="reference external" href="https://www.youtube.com/watch?v=yuDxHJOKsVA&amp;list=PLOFEBzvs-Vvp2xg9-POLJhQwtVktlYGbY&amp;index=8">Mitigating Noise on Real Quantum Computers</a></p></li>
</ul>
<p>Other relevant materials</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.feynmanlectures.caltech.edu/III_12.html">Feynman Lectures Ch. III - 12</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html">Quantum Operation</a></p></li>
<li><p><a class="reference external" href="https://nonhermitian.org/kaleido/stubs/kaleidoscope.interactive.bloch_sphere.html#kaleidoscope.interactive.bloch_sphere">Interactive Bloch Sphere</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-quantum-hardware/measurement-error-mitigation.html">Ch.5.2 Measurement Error Mitigation</a></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linalg</span> <span class="k">as</span> <span class="n">la</span>
<span class="kn">from</span> <span class="nn">qiskit.tools.monitor</span> <span class="kn">import</span> <span class="n">job_monitor</span>
<span class="kn">import</span> <span class="nn">qiskit.tools.jupyter</span>
</pre></div>
</div>
</div>
</div>
<h2 style="font-size:24px;">Measuring the state of a qubit</h2>
<br/>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
<p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
<p style=" padding: 0px 0px 10px 10px;
              font-size:16px;">Determine the Bloch components of a qubit.</p>
</div>
<p>Fundamental to the operation of a quantum computer is the ability to compute the Bloch components of a qubit or qubits. These components correspond to the expectation values of the Pauli operators <span class="math notranslate nohighlight">\(X, Y, Z\)</span>, and are important quantities for applications such as quantum chemistry and optimization.  Unfortunately, it is impossible to simultaneously compute these values, thus requiring many executions of the same circuit.  In addition, measurements are restricted to the computational basis (Z-basis) so that each Pauli needs to be rotated to the standard basis to access the x and y components.  Here we verify the methods by considering the case of a random vector on the Bloch sphere.</p>
<h3 style="font-size: 20px">📓 1. Express the expectation values of the Pauli operators for an arbitrary qubit state $|q\rangle$ in the computational basis. </h3>
<p>The case for the expectation value of Pauli Z gate is given as an example.</p>
<p>Using the diagonal representation, also known as spectral form or orthonormal decomposition, of Pauli <span class="math notranslate nohighlight">\(Z\)</span> gate and the relations among the Pauli gates (see <a class="reference external" href="https://qiskit.org/textbook/ch-states/single-qubit-gates.html">here</a>), expectation values of <span class="math notranslate nohighlight">\( X, Y, Z \)</span> gates can be written as</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\langle Z \rangle &amp;=\langle q | Z | q\rangle =\langle q|0\rangle\langle 0|q\rangle - \langle q|1\rangle\langle 1|q\rangle
=|\langle 0 |q\rangle|^2 - |\langle 1 | q\rangle|^2\\\\
\langle X \rangle &amp;= \langle q | X | q\rangle =\langle q | HZH | q\rangle = \langle q|H|0\rangle\langle 0|H|q\rangle - \langle q|H|1\rangle\langle 1|H|q\rangle
=|\langle 0| H |q\rangle|^2 - |\langle 1 | H |q\rangle|^2\\\\
\langle Y \rangle &amp;= |\langle 0| S^{\dagger}H |q\rangle|^2 - |\langle 1 | S^{\dagger}H |q\rangle|^2
\end{align}
\\
\end{split}\]</div>
<p>, respectively.</p>
<p>Therefore, the expectation values of the Paulis for a qubit state <span class="math notranslate nohighlight">\(|q\rangle\)</span> can be obtained by making a measurement in the standard basis after rotating the standard basis frame to lie along the corresponding axis. The probabilities of obtaining the two possible outcomes 0 and 1 are used to evaluate the desired expectation value as the above equations show.</p>
<h3 style="font-size: 20px">2. Measure the Bloch sphere coordinates of a qubit using the Aer simulator and plot the vector on the Bloch sphere.</h3><h4 style="font-size: 17px">📓Step A. Create a qubit state using the circuit method, <code>initialize</code> with two random complex numbers as the parameter.</h4>
<p>To learn how to use the function <code class="docutils literal notranslate"><span class="pre">initialize</span></code>, check <a class="reference external" href="https://qiskit.org/documentation/tutorials/circuits/3_summary_of_quantum_operations.html#Arbitrary-initialization">here</a>. (go to the <code class="docutils literal notranslate"><span class="pre">arbitrary</span> <span class="pre">initialization</span></code> section.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1">#### your code goes here</span>
<span class="c1"># random_statevector(2) # Alternative</span>

<span class="n">SignChoice</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">SignChoice</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
<span class="n">b</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">SignChoice</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
<span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">SignChoice</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
<span class="n">d</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">SignChoice</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>

<span class="n">p</span><span class="o">=</span><span class="nb">complex</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
<span class="n">q</span><span class="o">=</span><span class="nb">complex</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">)</span>
<span class="n">amplitudes</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">]</span>
<span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">)</span>

<span class="n">initial_state</span> <span class="o">=</span> <span class="n">amplitudes</span><span class="o">/</span><span class="n">norm</span>  <span class="c1"># Define state |q_0&gt;</span>
<span class="n">qc</span><span class="o">.</span><span class="n">initialize</span><span class="p">(</span><span class="n">initial_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;qiskit.circuit.instructionset.InstructionSet at 0x7f7ed36c4790&gt;
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">📓 Step B. Build the circuits to measure the expectation values of $X, Y, Z$ gate based on your answers to the question 1.  Run the cell below to estimate the Bloch sphere coordinates of the qubit from step A using the Aer simulator.</h4>
<p>The circuit for <span class="math notranslate nohighlight">\(Z\)</span> gate measurement is given as an example.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># z measurement of qubit 0</span>
<span class="n">measure_z</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">measure_z</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>


<span class="c1"># x measurement of qubit 0</span>
<span class="n">measure_x</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># your code goes here</span>
<span class="n">measure_x</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">measure_x</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>


<span class="c1"># y measurement of qubit 0</span>
<span class="n">measure_y</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># your code goes here</span>
<span class="n">measure_y</span><span class="o">.</span><span class="n">sdg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">measure_y</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">measure_y</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>


<span class="n">shots</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">14</span> <span class="c1"># number of samples used for statistics</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">'aer_simulator'</span><span class="p">)</span>
<span class="n">bloch_vector_measure</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">measure_circuit</span> <span class="ow">in</span> <span class="p">[</span><span class="n">measure_x</span><span class="p">,</span> <span class="n">measure_y</span><span class="p">,</span> <span class="n">measure_z</span><span class="p">]:</span>
    
    <span class="c1"># run the circuit with the selected measurement and get the number of samples that output each bit value</span>
    <span class="n">circ_trans</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">measure_circuit</span><span class="p">),</span> <span class="n">sim</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">circ_trans</span><span class="p">),</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>

    <span class="c1"># calculate the probabilities for each bit value</span>
    <span class="n">probs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span><span class="s1">'1'</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
            <span class="n">probs</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">output</span><span class="p">]</span><span class="o">/</span><span class="n">shots</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">probs</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
    <span class="n">bloch_vector_measure</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">probs</span><span class="p">[</span><span class="s1">'0'</span><span class="p">]</span> <span class="o">-</span>  <span class="n">probs</span><span class="p">[</span><span class="s1">'1'</span><span class="p">]</span> <span class="p">)</span>

<span class="c1"># normalizing the Bloch sphere vector</span>
<span class="n">bloch_vector</span> <span class="o">=</span> <span class="n">bloch_vector_measure</span><span class="o">/</span><span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bloch_vector_measure</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">'The Bloch sphere coordinates are [</span><span class="si">{0:4.3f}</span><span class="s1">, </span><span class="si">{1:4.3f}</span><span class="s1">, </span><span class="si">{2:4.3f}</span><span class="s1">]'</span>
      <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">bloch_vector</span><span class="p">))</span>    
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The Bloch sphere coordinates are [-0.690, 0.094, -0.717]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_bloch_vector</span>

<span class="n">plot_bloch_vector</span><span class="p">(</span> <span class="n">bloch_vector</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_31_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_31_0.png"/>
</div>
</div>
</div>
<div class="section" id="measuring-energy">
<h2>Measuring Energy<a class="headerlink" href="#measuring-energy" title="Permalink to this headline">¶</a></h2>
<br/>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
<p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
<p style=" padding: 0px 0px 10px 10px;
              font-size:16px;">Evaluate the energy levels of the hydrogen ground state using Aer simulator.</p>
</div>
<p>The energy of a quantum system can be estimated by measuring the expectation value of its Hamiltonian, which is a Hermitian operator, through the procedure we mastered in part 1.</p>
<p>The ground state of hydrogen is not defined as a single unique state but actually contains four different states due to the spins of the electron and proton. In part 2 of this lab, we evaluate the energy difference among these four states, which is from the <code class="docutils literal notranslate"><span class="pre">hyperfine</span> <span class="pre">splitting</span></code>, by computing the energy expectation value for the system of two spins with the Hamiltonian expressed in Pauli operators. For more information about <code class="docutils literal notranslate"><span class="pre">hyperfine</span> <span class="pre">structure</span></code>, see <a class="reference external" href="https://www.feynmanlectures.caltech.edu/III_12.html">here</a></p>
<p>Consider the system with two qubit interaction Hamiltonian <span class="math notranslate nohighlight">\(H = A(XX+YY+ZZ)\)</span> where <span class="math notranslate nohighlight">\(A = 1.47e^{-6} eV\)</span> and <span class="math notranslate nohighlight">\(X, Y, Z\)</span> are Pauli gates. Then the energy expectation value of the system can be evaluated by combining the expectation value of each term in the Hamiltonian.
In this case, <span class="math notranslate nohighlight">\(E = \langle H\rangle = A( \langle XX\rangle + \langle YY\rangle + \langle ZZ\rangle )\)</span>.</p>
<h3 style="font-size: 20px">📓 1. Express the expectation value of each term in the Hamiltonian for an arbitrary two qubit state   $|\psi \rangle$ in the computational basis.</h3>
<p>The case for the term <span class="math notranslate nohighlight">\(\langle ZZ\rangle\)</span> is given as an example.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\langle ZZ\rangle &amp;=\langle \psi | ZZ | \psi\rangle =\langle \psi|(|0\rangle\langle 0| - |1\rangle\langle 1|)\otimes(|0\rangle\langle 0| - |1\rangle\langle 1|) |\psi\rangle
=|\langle 00|\psi\rangle|^2 - |\langle 01 | \psi\rangle|^2 - |\langle 10 | \psi\rangle|^2 + |\langle 11|\psi\rangle|^2\\\\
\langle XX\rangle &amp;= \langle \psi | XX | \psi\rangle = \langle \psi | HZH\otimes HZH | \psi\rangle = |\langle 00|HH|\psi\rangle|^2 - |\langle 01|HH | \psi\rangle|^2 - |\langle 10|HH | \psi\rangle|^2 + |\langle 11|HH|\psi\rangle|^2\\\\
\langle YY\rangle &amp;= |\langle 00|(S^{\dagger}H)(S^{\dagger}H)|\psi\rangle|^2 - |\langle 01|(S^{\dagger}H)(S^{\dagger}H) | \psi\rangle|^2 - |\langle 10|(S^{\dagger}H)(S^{\dagger}H) | \psi\rangle|^2 + |\langle 11|(S^{\dagger}H)(S^{\dagger}H)|\psi\rangle|^2
\end{align}
\end{split}\]</div>
<h3 style="font-size: 20px">2. Measure the expected energy of the system using the Aer simulator when two qubits are entangled. Regard the bell basis, four different entangled states.</h3><h4 style="font-size: 17px">📓Step A. Construct the circuits to prepare four different bell states.</h4>
<p>Let’s label each bell state as
$<span class="math notranslate nohighlight">\(
\begin{align}
Tri1 &amp;= \frac{1}{\sqrt2} (|00\rangle + |11\rangle)\\
Tri2 &amp;= \frac{1}{\sqrt2} (|00\rangle - |11\rangle)\\
Tri3 &amp;= \frac{1}{\sqrt2} (|01\rangle + |10\rangle)\\
Sing &amp;= \frac{1}{\sqrt2} (|10\rangle - |01\rangle)
\end{align}
\)</span>$</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># circuit for the state Tri1</span>
<span class="n">Tri1</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># your code goes here</span>
<span class="n">Tri1</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">Tri1</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>


<span class="c1"># circuit for the state Tri2</span>
<span class="n">Tri2</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># your code goes here</span>
<span class="n">Tri2</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">Tri2</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Tri2</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="c1"># circuit for the state Tri3</span>
<span class="n">Tri3</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># your code goes here</span>
<span class="n">Tri3</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">Tri3</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Tri3</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="c1"># circuit for the state Sing</span>
<span class="n">Sing</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># your code goes here</span>
<span class="n">Sing</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">Sing</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Sing</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Sing</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;qiskit.circuit.instructionset.InstructionSet at 0x7f7ed5d30690&gt;
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">📓Step B. Create the circuits to measure the expectation value of each term in the Hamiltonian based on your answer to the question 1.</h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># &lt;ZZ&gt; </span>
<span class="n">measure_ZZ</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">measure_ZZ</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="c1"># &lt;XX&gt;</span>
<span class="n">measure_XX</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># your code goes here</span>
<span class="n">measure_XX</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">measure_XX</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">measure_XX</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>


<span class="c1"># &lt;YY&gt;</span>
<span class="n">measure_YY</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># your code goes here</span>
<span class="n">measure_YY</span><span class="o">.</span><span class="n">sdg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">measure_YY</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">measure_YY</span><span class="o">.</span><span class="n">sdg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">measure_YY</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">measure_YY</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">Step C. Execute the circuits on Aer simulator by running the cell below and evaluate the energy expectation value for each state.</h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">shots</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">14</span> <span class="c1"># number of samples used for statistics</span>

<span class="n">A</span> <span class="o">=</span> <span class="mf">1.47e-6</span> <span class="c1">#unit of A is eV</span>
<span class="n">E_sim</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">state_init</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Tri1</span><span class="p">,</span><span class="n">Tri2</span><span class="p">,</span><span class="n">Tri3</span><span class="p">,</span><span class="n">Sing</span><span class="p">]:</span>
    <span class="n">Energy_meas</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">measure_circuit</span> <span class="ow">in</span> <span class="p">[</span><span class="n">measure_XX</span><span class="p">,</span> <span class="n">measure_YY</span><span class="p">,</span> <span class="n">measure_ZZ</span><span class="p">]:</span>
    
        <span class="c1"># run the circuit with the selected measurement and get the number of samples that output each bit value</span>
        <span class="n">qc</span> <span class="o">=</span> <span class="n">state_init</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">measure_circuit</span><span class="p">)</span>
        <span class="n">qc_trans</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc</span><span class="p">,</span> <span class="n">sim</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_trans</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>

        <span class="c1"># calculate the probabilities for each computational basis</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'00'</span><span class="p">,</span><span class="s1">'01'</span><span class="p">,</span> <span class="s1">'10'</span><span class="p">,</span> <span class="s1">'11'</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">output</span><span class="p">]</span><span class="o">/</span><span class="n">shots</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="n">Energy_meas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">probs</span><span class="p">[</span><span class="s1">'00'</span><span class="p">]</span> <span class="o">-</span> <span class="n">probs</span><span class="p">[</span><span class="s1">'01'</span><span class="p">]</span> <span class="o">-</span> <span class="n">probs</span><span class="p">[</span><span class="s1">'10'</span><span class="p">]</span> <span class="o">+</span> <span class="n">probs</span><span class="p">[</span><span class="s1">'11'</span><span class="p">]</span> <span class="p">)</span>
 
    <span class="n">E_sim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Energy_meas</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run this cell to print out your results</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">'Energy expectation value of the state Tri1 : </span><span class="si">{:.3e}</span><span class="s1"> eV'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E_sim</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Energy expectation value of the state Tri2 : </span><span class="si">{:.3e}</span><span class="s1"> eV'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E_sim</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Energy expectation value of the state Tri3 : </span><span class="si">{:.3e}</span><span class="s1"> eV'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E_sim</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Energy expectation value of the state Sing : </span><span class="si">{:.3e}</span><span class="s1"> eV'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E_sim</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Energy expectation value of the state Tri1 : 1.470e-06 eV
Energy expectation value of the state Tri2 : 1.470e-06 eV
Energy expectation value of the state Tri3 : 1.470e-06 eV
Energy expectation value of the state Sing : -4.410e-06 eV
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">Step D. Understanding the result. </h4>
<p>If you found the energy expectation values successfully, you would have obtained exactly the same value, <span class="math notranslate nohighlight">\(A (= 1.47e^{-6} eV)\)</span>, for the triplet states, <span class="math notranslate nohighlight">\(|Tri1\rangle, |Tri2\rangle, |Tri3\rangle\)</span> and one lower energy level, <span class="math notranslate nohighlight">\(-3A (= -4.41e^{-6} eV)\)</span> for the singlet state <span class="math notranslate nohighlight">\(|Sing\rangle\)</span>.</p>
<p>What we have done here is measuring the energies of the four different spin states corresponding to the ground state of hydrogen and observed <code class="docutils literal notranslate"><span class="pre">hyperfine</span> <span class="pre">structure</span></code> in the energy levels caused by spin-spin coupling.  This tiny energy difference between the singlet and triplet states is the reason for the famous 21-cm wavelength radiation used to map the structure of the galaxy.</p>
<p>In the cell below, we verify the wavelength of the emission from the transition between the triplet states and singlet state.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># reduced plank constant in (eV) and the speed of light(cgs units)</span>
<span class="n">hbar</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">4.1357e-15</span><span class="p">,</span> <span class="mf">3e10</span>

<span class="c1"># energy difference between the triplets and singlet</span>
<span class="n">E_del</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">E_sim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">E_sim</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

<span class="c1"># frequency associated with the energy difference</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">E_del</span><span class="o">/</span><span class="n">hbar</span>

<span class="c1"># convert frequency to wavelength in (cm) </span>
<span class="n">wavelength</span> <span class="o">=</span> <span class="n">c</span><span class="o">/</span><span class="n">f</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">'The wavelength of the radiation from the transition</span><span class="se">\</span>
<span class="s1"> in the hyperfine structure is : </span><span class="si">{:.1f}</span><span class="s1"> cm'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wavelength</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The wavelength of the radiation from the transition in the hyperfine structure is : 21.1 cm
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="quantum-teleportation">
<h2>Quantum teleportation<a class="headerlink" href="#quantum-teleportation" title="Permalink to this headline">¶</a></h2>
<br/>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
<p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
<p style=" padding: 0px 0px 10px 10px;
              font-size:16px;">To show how quantum teleportation is performed and how Pauli correction is made depends on the measurement result.</p>
</div>
<p>For this exercise, we will see how quantum teleportation is performed using an entangled state as a resource. Importantly, to transfer one qubit faithfully to another, an additional Pauli rotation needs to be applied <span class="math notranslate nohighlight">\(\textit{depending on the measurement result of the original qubit}\)</span>.</p>
<h4 style="font-size: 17px">Step A. Generate a random single qubit and plot it on the Bloch sphere. </h4>
<p>Hint: qiskit.quantum_info may have useful methods.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">random_statevector</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span><span class="p">,</span> <span class="n">plot_bloch_multivector</span><span class="p">,</span> <span class="n">array_to_latex</span>

<span class="c1"># Create random 1-qubit state</span>
<span class="n">psi</span> <span class="o">=</span> <span class="n">random_statevector</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Display it nicely</span>
<span class="n">display</span><span class="p">(</span><span class="n">array_to_latex</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">"|</span><span class="se">\\</span><span class="s2">psi</span><span class="se">\\</span><span class="s2">rangle ="</span><span class="p">))</span>
<span class="c1"># Show it on a Bloch sphere</span>
<span class="n">plot_bloch_multivector</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}
|\psi\rangle =
\begin{bmatrix}
0.16175 + 0.21926i &amp; 0.78702 - 0.5535i  \\
 \end{bmatrix}
\end{split}\]</div>
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_48_1.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_48_1.png"/>
</div>
</div>
<h4 style="font-size: 17px">Step B. Create a quantum teleportation circuit. </h4>
<p>Construct a quantum circuit that has <em>two</em> qubits. One is the random single qubit <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> produced above, and another is a qubit initialized as <span class="math notranslate nohighlight">\(|0\rangle\)</span> and will be mapped to <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>, i.e. <span class="math notranslate nohighlight">\(|0\rangle\rightarrow |\psi\rangle\)</span>. The Qiskit chapter on quantum teleportation may be helpful: <a class="reference external" href="https://qiskit.org/textbook/ch-algorithms/teleportation.html">https://qiskit.org/textbook/ch-algorithms/teleportation.html</a></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># circuit for quantum teleportation</span>
<span class="kn">from</span> <span class="nn">qiskit.extensions</span> <span class="kn">import</span> <span class="n">Initialize</span>
<span class="c1"># arbitrary psi</span>
<span class="n">init_gate</span> <span class="o">=</span> <span class="n">Initialize</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
<span class="n">init_gate</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s2">"init"</span>
<span class="n">qc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">init_gate</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">qc</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

<span class="n">qc</span><span class="o">.</span><span class="n">cz</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">c_if</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># if classical bit 0 measures 1, applies x on qubit 1</span>
<span class="n">qc</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>     ┌────────────────────────────────────────┐      ░    ┌───┐┌─┐ ░      »
q_0: ┤ init(0.16175+0.21926j,0.78702-0.5535j) ├──────░──■─┤ H ├┤M├─░──────»
     └────────────────────────────────────────┘┌───┐ ░  │ └───┘└╥┘ ░ ┌───┐»
q_1: ───────────────────|0&gt;────────────────────┤ H ├─░──■───────╫──░─┤ H ├»
                                               └───┘ ░          ║  ░ └───┘»
c: 1/═══════════════════════════════════════════════════════════╩═════════»
                                                                0         »
«                
«q_0: ───────────
«        ┌───┐   
«q_1: ───┤ X ├───
«        └─╥─┘   
«     ┌────╨────┐
«c: 1/╡ c_0=0x1 ╞
«     └─────────┘</pre></div></div>
</div>
<h4 style="font-size: 17px">Step C. Plot the teleported qubit. </h4>
<p>Plot the teleported qubit on a Bloch sphere and confirm you indeed have recovered the same state as one shown in Step A.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">'aer_simulator'</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">save_statevector</span><span class="p">()</span>
<span class="n">out_vector</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">()</span>
<span class="n">plot_bloch_multivector</span><span class="p">(</span><span class="n">out_vector</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_52_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_52_0.png"/>
</div>
</div>
</div>
<div class="section" id="part-3-accuracy-of-quantum-phase-estimation">
<h2>Part 3 Accuracy of Quantum Phase Estimation<a class="headerlink" href="#part-3-accuracy-of-quantum-phase-estimation" title="Permalink to this headline">¶</a></h2>
<p>Prerequisite</p>
<ul class="simple">
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-algorithms/quantum-fourier-transform.html">Ch.3.5 Quantum Fourier Transform</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html">Ch.3.6 Quantum Phase Estimation</a></p></li>
</ul>
<p>Other relevant materials</p>
<ul class="simple">
<li><p>[QCQI] Michael A. Nielsen and Isaac L. Chuang. 2011. Quantum Computation and Quantum Information</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="kn">import</span> <span class="nn">qiskit.tools.jupyter</span>
<span class="kn">from</span> <span class="nn">qiskit.tools.monitor</span> <span class="kn">import</span> <span class="n">job_monitor</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="performance-of-quantum-phase-estimation">
<h3>Performance of Quantum Phase Estimation<a class="headerlink" href="#performance-of-quantum-phase-estimation" title="Permalink to this headline">¶</a></h3>
<br/>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
<p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
<p style=" padding: 0px 0px 10px 10px;
              font-size:16px;">Investigate the relationship between the number of qubits required for the desired accuracy of the phase estimation with high probability.</p>
</div>
<p>The accuracy of the estimated value through Quantum Phase Estimation (QPE) and its probability of success depend on the number of qubits employed in QPE circuits. Therefore, one might want to know the necessary number of qubits to achieve the targeted level of QPE performance, especially when the phase that needs to be determined cannot be decomposed in a finite bit binary expansion.
In Part 1 of this lab, we examine the number of qubits required to accomplish the desired accuracy and the probability of success in determining the phase through QPE.</p>
<h3 style="font-size: 20px">1. Find the probability of obtaining the estimation for a phase value accurate to $2^{-2}$ successfully with four counting qubits.</h3> <h4 style="font-size: 17px">📓Step A. Set up the QPE circuit with four counting qubits and save the circuit to the variable 'qc4'.  Execute 'qc4' on a Aer simulator.  Plot the histogram of the result.</h4><p>Check the QPE chapter in Qiskit textbook ( go to <code class="docutils literal notranslate"><span class="pre">3.</span> <span class="pre">Example:</span> <span class="pre">Getting</span> <span class="pre">More</span> <span class="pre">Precision</span></code> section <a class="reference external" href="https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html#3.-Example:-Getting-More-Precision-">here</a> ) for the circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qft</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Creates an n-qubit QFT circuit"""</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">swap_registers</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">qubit</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">circuit</span>
    <span class="k">def</span> <span class="nf">qft_rotations</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Performs qft on the first n qubits in circuit (without swaps)"""</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">circuit</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">cp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">qubit</span><span class="p">),</span> <span class="n">qubit</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">qft_rotations</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    
    <span class="n">qft_rotations</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">swap_registers</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">circuit</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Start your code to create the circuit, qc4</span>
<span class="c1"># Create inverse QFT</span>
<span class="n">qft_circ</span> <span class="o">=</span> <span class="n">qft</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="c1"># Then we take the inverse of this circuit</span>
<span class="n">invqft_circ</span> <span class="o">=</span> <span class="n">qft_circ</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>

<span class="c1"># Create and set up circuit</span>
<span class="n">qc4</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

<span class="c1"># Apply H-Gates to counting qubits:</span>
<span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">qc4</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>

<span class="c1"># Prepare our eigenstate |psi&gt;:</span>
<span class="n">qc4</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># Do the controlled-U operations:</span>
<span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span>
<span class="n">repetitions</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">counting_qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repetitions</span><span class="p">):</span>
        <span class="n">qc4</span><span class="o">.</span><span class="n">cp</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">counting_qubit</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">repetitions</span> <span class="o">*=</span> <span class="mi">2</span>

<span class="c1"># Do the inverse QFT:</span>
<span class="c1"># qc4 = qc4.compose(qft(4, inverse=True), range(4))</span>
<span class="n">qc4</span> <span class="o">=</span> <span class="n">qc4</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">invqft_circ</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>

<span class="c1"># Measure of course!</span>
<span class="n">qc4</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">qc4</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>


<span class="n">qc4</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><pre style='word-wrap: normal;white-space: pre;background: #fff0;line-height: 1.1;font-family: "Courier New",Courier,monospace'>     ┌───┐                                                            »
q_0: ┤ H ├─■──────────────────────────────────────────────────────────»
     ├───┤ │                                                          »
q_1: ┤ H ├─┼─────────■─────────■──────────────────────────────────────»
     ├───┤ │         │         │                                      »
q_2: ┤ H ├─┼─────────┼─────────┼─────────■─────────■─────────■────────»
     ├───┤ │         │         │         │         │         │        »
q_3: ┤ H ├─┼─────────┼─────────┼─────────┼─────────┼─────────┼────────»
     ├───┤ │P(2π/3)  │P(2π/3)  │P(2π/3)  │P(2π/3)  │P(2π/3)  │P(2π/3) »
q_4: ┤ X ├─■─────────■─────────■─────────■─────────■─────────■────────»
     └───┘                                                            »
c: 4/═════════════════════════════════════════════════════════════════»
                                                                      »
«                                                                           »
«q_0: ──────────────────────────────────────────────────────────────────────»
«                                                                           »
«q_1: ──────────────X───────────────────────────────────────────────────────»
«                   │                                                       »
«q_2: ─■────────────X───────────────────────────────────────────────────────»
«      │                                                                    »
«q_3: ─┼─────────■─────────■─────────■─────────■─────────■─────────■────────»
«      │P(2π/3)  │P(2π/3)  │P(2π/3)  │P(2π/3)  │P(2π/3)  │P(2π/3)  │P(2π/3) »
«q_4: ─■─────────■─────────■─────────■─────────■─────────■─────────■────────»
«                                                                           »
«c: 4/══════════════════════════════════════════════════════════════════════»
«                                                                           »
«                            ┌───┐                                        »
«q_0: ─────────────────────X─┤ H ├─■────────────────────────■─────────────»
«                          │ └───┘ │P(-π/2) ┌───┐           │             »
«q_1: ─────────────────────┼───────■────────┤ H ├─■─────────┼─────────────»
«                          │                └───┘ │P(-π/2)  │P(-π/4) ┌───┐»
«q_2: ─────────────────────┼──────────────────────■─────────■────────┤ H ├»
«                          │                                         └───┘»
«q_3: ─■─────────■─────────X──────────────────────────────────────────────»
«      │P(2π/3)  │P(2π/3)                                                 »
«q_4: ─■─────────■────────────────────────────────────────────────────────»
«                                                                         »
«c: 4/════════════════════════════════════════════════════════════════════»
«                                                                         »
«                                         ░ ┌─┐         
«q_0: ─────────────────────■──────────────░─┤M├─────────
«                          │              ░ └╥┘┌─┐      
«q_1: ───────────■─────────┼──────────────░──╫─┤M├──────
«                │         │              ░  ║ └╥┘┌─┐   
«q_2: ─■─────────┼─────────┼──────────────░──╫──╫─┤M├───
«      │P(-π/2)  │P(-π/4)  │P(-π/8) ┌───┐ ░  ║  ║ └╥┘┌─┐
«q_3: ─■─────────■─────────■────────┤ H ├─░──╫──╫──╫─┤M├
«                                   └───┘ ░  ║  ║  ║ └╥┘
«q_4: ────────────────────────────────────░──╫──╫──╫──╫─
«                                         ░  ║  ║  ║  ║ 
«c: 4/═══════════════════════════════════════╩══╩══╩══╩═
«                                            0  1  2  3 </pre></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Run this cell to simulate 'qc4' and to plot the histogram of the result</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">'aer_simulator'</span><span class="p">)</span>
<span class="n">shots</span> <span class="o">=</span> <span class="mi">20000</span>
<span class="n">count_qc4</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">qc4</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">count_qc4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_62_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_62_0.png"/>
</div>
</div>
<p>Having performed <code class="docutils literal notranslate"><span class="pre">Step</span> <span class="pre">A</span></code> successfully, you will have obtained a distribution similar to the one shown below with the highest probability at <code class="docutils literal notranslate"><span class="pre">0101</span></code> which corresponds to the estimated <span class="math notranslate nohighlight">\(\phi\)</span> value, <code class="docutils literal notranslate"><span class="pre">0.3125</span></code>.</p>
<p>Since the number of counting qubits used for the circuit is four, the best estimated value should be accurate to <span class="math notranslate nohighlight">\(\delta = 2^{-4} = 0.0625\)</span>.  However, there are multiple possible outcomes as <span class="math notranslate nohighlight">\(\theta = 1/3\)</span> cannot be expressed in a finite number of bits, the estimation by QPE here is not always bounded by this accuracy.</p>
<p>Running the following cell shows the same histogram but with all possible estimated <span class="math notranslate nohighlight">\(\phi\)</span> values on the x-axis.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span><span class="o">=</span><span class="mi">4</span>
<span class="n">phi_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">round</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">count_qc4</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
<span class="n">key_new</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">phi_est</span><span class="p">))</span>
<span class="n">count_new</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">key_new</span><span class="p">,</span> <span class="n">count_qc4</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">count_new</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_66_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_66_0.png"/>
</div>
</div>
<p><strong>Suppose the outcome of the final measurement is <span class="math notranslate nohighlight">\(m\)</span>, and let <span class="math notranslate nohighlight">\(b\)</span> the best estimation which is <code class="docutils literal notranslate"><span class="pre">0.3125</span></code> for this case.</strong></p>
<h4 style="font-size: 17px">📓Step B. Find $e$, the maximum difference in integer from the best estimation <code>0101</code> so that all the outcomes, 'm's, would approximate $\phi$ to an accuracy $2^{-2}$ when $|m - b| \leq \frac{e}{2^{t}}$. </h4><p>In this case, the values of <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are <span class="math notranslate nohighlight">\(4\)</span> and <span class="math notranslate nohighlight">\(0.3125\)</span>, respectively.</p>
<p>For example, under <span class="math notranslate nohighlight">\(e = 1\)</span>, the considered outcomes are <code class="docutils literal notranslate"><span class="pre">0100</span></code>, <code class="docutils literal notranslate"><span class="pre">0101</span></code>, <code class="docutils literal notranslate"><span class="pre">0110</span></code> which correspond to the values of <span class="math notranslate nohighlight">\(m\)</span>: <span class="math notranslate nohighlight">\(0.25,~0.312,~0.375\)</span>, respectively, and all of them approximate the value <span class="math notranslate nohighlight">\(\frac{1}{3}\)</span> to an accuracy <span class="math notranslate nohighlight">\(2^{-2}\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your code goes here</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">b</span> <span class="o">=</span> <span class="mf">0.3125</span>
<span class="n">accur</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="n">max_e</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">max_e</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_e</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="o">+</span><span class="n">b</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">max_e</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="o">+</span><span class="n">b</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="o">-</span><span class="n">accur</span><span class="o">&gt;</span><span class="n">lower_bound</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="o">+</span><span class="n">accur</span><span class="o">&lt;</span><span class="n">upper_bound</span><span class="p">):</span>
        <span class="n">max_e</span><span class="o">-=</span><span class="mi">1</span>
        <span class="k">break</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Maximum e: </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_e</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Maximum e: 3
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">📓Step C. Compute the probability of obtaining an approximation correct to an accuracy $2^{-2}$.  Verify that the computed probability value is larger or equal to $1- \frac{1}{2(2^{(t-n)}-2)}$ where $t$ is the number of counting bits and the $2^{-n}$ is the desired accuracy. </h4><p>Now it is easy to evaluate the probability of the success from the histogram since all the outcomes that approximate <span class="math notranslate nohighlight">\(\phi\)</span> to the accuracy <span class="math notranslate nohighlight">\(2^{-2}\)</span> can be found based on the maximum difference <span class="math notranslate nohighlight">\(e\)</span> from the best estimate.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your code goes here</span>
<span class="n">t</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">e</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">lower_bound</span> <span class="o">=</span> <span class="o">-</span><span class="n">e</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="o">+</span><span class="n">b</span>
<span class="n">upper_bound</span> <span class="o">=</span> <span class="n">e</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="o">+</span><span class="n">b</span>
<span class="n">threshold</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="n">within_target</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">count_new</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
    <span class="n">val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="n">total</span><span class="o">+=</span><span class="n">count_new</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="o">&gt;</span><span class="n">lower_bound</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">val</span><span class="o">&lt;</span><span class="n">upper_bound</span><span class="p">):</span>
        <span class="n">within_target</span><span class="o">+=</span><span class="n">count_new</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Probability of success within accuracy </span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">2</span><span class="o">**-</span><span class="mi">2</span><span class="p">,</span><span class="n">within_target</span><span class="o">/</span><span class="n">total</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Threshold probability: </span><span class="si">{}</span><span class="s1">'</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">threshold</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Probability of success within accuracy 0.25: 0.94515
Threshold probability: 0.75
</pre></div>
</div>
</div>
</div>
<h3 style="font-size: 20px">2. Compute the probability of success for the accuracy $2^{-2}$ when the number of counting qubits, $t$, varies from four to nine. Compare your result with the equation $t=n+log(2+\frac{1}{2\epsilon})$ when $2^{-n}$ is the desired accuracy and $\epsilon$ is 1 - probability  of success.</h3> <p>The following plot shows the relationship between the number of counting qubit, t, and the minimum probability of success to approximate the phase to an accuracy <span class="math notranslate nohighlight">\(2^{-2}\)</span>.  Check the Ch. 5.2.1 Performance and requirements in <code class="docutils literal notranslate"><span class="pre">[QCQI]</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="n">t_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">9.5</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span>
<span class="n">p_min</span> <span class="o">=</span> <span class="n">y</span><span class="p">(</span><span class="n">t_q</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_q</span><span class="p">,</span> <span class="n">p_min</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">'$p_</span><span class="si">{min}</span><span class="s1">$'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'t: number of counting qubits'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'probability of success for the accuracy $2^{-2}$'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">'lower right'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Probability of success for different number of counting qubits'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_76_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_76_0.png"/>
</div>
</div>
<h4 style="font-size: 17px">📓Step A. Construct QPE circuit to estimate $\phi$ when $\phi = 1/3$ with for the different number of counting qubits, $t$, when $t = [4, 5, 6, 7, 8, 9]$. Store all the circuits in a list variable 'circ' to simulate all the circuits at once as we did in Lab2. </h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your Code to create the list variable 'circ' goes here</span>
<span class="n">circ</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">ts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>

<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span>
    <span class="c1"># Create inverse QFT</span>
    <span class="n">qft_circ</span> <span class="o">=</span> <span class="n">qft</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="c1"># Then we take the inverse of this circuit</span>
    <span class="n">invqft_circ</span> <span class="o">=</span> <span class="n">qft_circ</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>

    <span class="c1"># Create and set up circuit</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

    <span class="c1"># Apply H-Gates to counting qubits:</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>

    <span class="c1"># Prepare our eigenstate |psi&gt;:</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="c1"># Do the controlled-U operations:</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span>
    <span class="n">repetitions</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">counting_qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">repetitions</span><span class="p">):</span>
            <span class="n">qc</span><span class="o">.</span><span class="n">cp</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">counting_qubit</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
        <span class="n">repetitions</span> <span class="o">*=</span> <span class="mi">2</span>

    <span class="c1"># Do the inverse QFT:</span>
    <span class="n">qc</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">invqft_circ</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="c1"># Measure of course!</span>
    <span class="n">qc</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    
    <span class="c1"># Append each QPE circuit to 'circ'</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Run this cell to simulate `circ` and plot the histograms of the results</span>

<span class="n">results</span> <span class="o">=</span> <span class="n">execute</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="n">n_circ</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
<span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="n">results</span><span class="o">.</span><span class="n">get_counts</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_circ</span><span class="p">)]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">n_circ</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span><span class="mi">40</span><span class="p">))</span>
<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_circ</span><span class="p">):</span>
    <span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_79_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_79_0.png"/>
</div>
</div>
<h4 style="font-size: 17px">📓Step B. Determine $e$, the maximum difference in integer from the best estimation for the different number of counting qubits, $t = [4, 5, 6, 7, 8, 9]$. Verify the relationship $e=2^{t-n}-1$ where $n=2$ since the desired accuracy is $2^{-2}$ in this case. </h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your Code goes here</span>
<span class="n">es</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">calc_es</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">]</span>
<span class="n">accur</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>

<span class="k">for</span> <span class="n">ind</span><span class="p">,</span><span class="n">count_qc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">counts</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    <span class="n">count_qc</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

    <span class="n">phi_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">round</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">count_qc</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
    <span class="n">key_new</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">phi_est</span><span class="p">))</span>
    <span class="n">count_new</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">key_new</span><span class="p">,</span> <span class="n">count_qc</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="n">b</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">count_new</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">count_new</span><span class="o">.</span><span class="n">get</span><span class="p">))</span>

    <span class="n">max_e</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">max_e</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">lower_bound</span> <span class="o">=</span> <span class="o">-</span><span class="n">max_e</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="o">+</span><span class="n">b</span>
        <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">max_e</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="o">+</span><span class="n">b</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="o">-</span><span class="n">accur</span><span class="o">&gt;</span><span class="n">lower_bound</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="o">+</span><span class="n">accur</span><span class="o">&lt;</span><span class="n">upper_bound</span><span class="p">):</span>
            <span class="n">max_e</span><span class="o">-=</span><span class="mi">1</span>
            <span class="k">break</span>
    <span class="n">es</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">max_e</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Obtained: '</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">es</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Calculated: '</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">calc_es</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Obtained: [3, 7, 15, 31, 63, 127]
Calculated: [3, 7, 15, 31, 63, 127]
</pre></div>
</div>
</div>
</div>
<p>If you successfully calculated <span class="math notranslate nohighlight">\(e\)</span> values for all the counting qubits, <span class="math notranslate nohighlight">\(t=[4,5,6,7,8,9]\)</span>, you will be able to generate the following graph that verifies the relationship <span class="math notranslate nohighlight">\(e = 2^{t-2} -1\)</span> with the <span class="math notranslate nohighlight">\(e\)</span> values that you computed.</p>
<h4 style="font-size: 17px">📓Step C. Evaluate the probability of success estimating $\phi$ to an accuracy $2^{-2}$ for all the values of $t$, the number of counting qubits. Save the probabilities to the list variable, 'prob_success'.  </h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your code to create the list variable, 'prob_success',  goes here</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">prob_success</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">ind</span><span class="p">,</span><span class="n">count_qc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">counts</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">ts</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    <span class="n">count_qc</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">es</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    
    <span class="n">phi_est</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">round</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">count_qc</span><span class="o">.</span><span class="n">keys</span><span class="p">())])</span>
    <span class="n">key_new</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">phi_est</span><span class="p">))</span>
    <span class="n">count_new</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">key_new</span><span class="p">,</span> <span class="n">count_qc</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    
    <span class="n">lower_bound</span> <span class="o">=</span> <span class="o">-</span><span class="n">e</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="o">+</span><span class="n">b</span>
    <span class="n">upper_bound</span> <span class="o">=</span> <span class="n">e</span><span class="o">/</span><span class="mi">2</span><span class="o">**</span><span class="n">t</span><span class="o">+</span><span class="n">b</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">within_target</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">count_new</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">total</span><span class="o">+=</span><span class="n">count_new</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="o">&gt;</span><span class="n">lower_bound</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">val</span><span class="o">&lt;</span><span class="n">upper_bound</span><span class="p">):</span>
            <span class="n">within_target</span><span class="o">+=</span><span class="n">count_new</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="n">prob_success</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">within_target</span><span class="o">/</span><span class="n">total</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'Success probabilities: '</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">prob_success</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Success probabilities: [0.9575, 0.98225, 0.99065, 0.9957, 0.99825, 0.99885]
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">📓Step D. Overlay the results of Step C on the graph that shows the relationship between the number of counting qubits, $t$, and the minimum probability of success to approximate the phase to an accuracy $2^{-2}$. Understand the result.  </h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your code goes here</span>
<span class="n">y</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">n</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>
<span class="n">t_q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">9.5</span><span class="p">,</span> <span class="mi">100</span> <span class="p">)</span>
<span class="n">p_min</span> <span class="o">=</span> <span class="n">y</span><span class="p">(</span><span class="n">t_q</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_q</span><span class="p">,</span> <span class="n">p_min</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">'$p_</span><span class="si">{min}</span><span class="s1">$'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="n">prob_success</span><span class="p">,</span> <span class="s1">'-o'</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">'Step C'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'t: number of counting qubits'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'probability of success for the accuracy $2^{-2}$'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">'lower right'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Probability of success for different number of counting qubits'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_86_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_86_0.png"/>
</div>
</div>
<p>Your plot should be similar to the above one.
The line plot in the left panel shows the minimum success probability to estimate <span class="math notranslate nohighlight">\(\phi\)</span> within the accuracy <span class="math notranslate nohighlight">\(2^{-2}\)</span> as the number of counting qubits varies. The overlaid orange dots are the same values, but from the simulation, which confirms the relationship the line plot represents as the lower bound.  The right panel displays the same result but zoomed by adjusting the y-axis range.</p>
<p>The following graph exhibits the relationships with different accuracy levels.  The relationship, <span class="math notranslate nohighlight">\(t=n+log(2+\frac{1}{2\epsilon})\)</span>, indicates the number of counting qubits <span class="math notranslate nohighlight">\(t\)</span> to estimate <span class="math notranslate nohighlight">\(\phi\)</span> to an accuracy <span class="math notranslate nohighlight">\(2^{-2}\)</span> with probability of success at least <span class="math notranslate nohighlight">\(1-\epsilon\)</span>, as we validated above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">5.1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">prob_success_n</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
<span class="n">prob_n2</span><span class="p">,</span> <span class="n">prob_n3</span><span class="p">,</span> <span class="n">prob_n4</span>  <span class="o">=</span> <span class="n">prob_success_n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">prob_success_n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">prob_success_n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">prob_n2</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">prob_n3</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">prob_n4</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span><span class="s1">'--'</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">1.05</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'t: number of counting qubits'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'probability of success for the accuracy $2^{-n}$'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">'n = 2'</span><span class="p">,</span> <span class="s1">'n = 3'</span><span class="p">,</span> <span class="s1">'n = 4'</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s1">'lower right'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_89_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_89_0.png"/>
</div>
</div>
</div>
</div>
<div class="section" id="part-4-quantum-error-correction">
<h2>Part 4 Quantum Error Correction<a class="headerlink" href="#part-4-quantum-error-correction" title="Permalink to this headline">¶</a></h2>
<p>Prerequisite</p>
<ul class="simple">
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-quantum-hardware/error-correction-repetition-code.html#Storing-qubits">5.1 Introduction to Quantum Error Correction</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html">3.6 Quantum Phase Estimation</a></p></li>
</ul>
<p>Other relevant materials</p>
<ul class="simple">
<li><p><a class="reference external" href="https://qiskit.org/documentation/stubs/qiskit.quantum_info.Statevector.html#qiskit.quantum_info.Statevector.from_instruction">Statevector method</a></p></li>
<li><p><a class="reference external" href="https://qiskit.org/documentation/tutorials/circuits/2_plotting_data_in_qiskit.html#Plot-State">qsphere</a></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_histogram</span>
<span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="kn">import</span> <span class="n">plot_state_qsphere</span><span class="p">,</span> <span class="n">plot_bloch_vector</span>

<span class="kn">from</span> <span class="nn">qiskit.quantum_info</span> <span class="kn">import</span> <span class="n">Statevector</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sim</span> <span class="o">=</span> <span class="n">Aer</span><span class="o">.</span><span class="n">get_backend</span><span class="p">(</span><span class="s1">'aer_simulator'</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<h2 style="font-size:24px;"> 3-qubit code </h2>
<br/>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
<p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
<p style=" padding: 0px 0px 10px 10px;
              font-size:16px;"> Create circuits for 3-qubit code that encodes a one qubit state into a three qubit code state and utilize partiy check to detect and localise either bit-flip ( X ) or phase-flip ( Z ) errors on a single qubit in the codes.</p>
</div><h3 style="font-size: 20px"> 1. Detect and locate a single bit-flip ( X ) error utilizing 3-qubit code and parity check circuit.</h3><h4 style="font-size: 17px">📓Step A. Create a circuit to encode the state $|\psi\rangle = \frac{1}{\sqrt{2}}(|0\rangle + i|1\rangle)$ into 3-qubit code state, $\frac{1}{\sqrt{2}}(|000\rangle + i|111\rangle)$ to be protected from one bit-flip ( X ) error.</h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc_3qx</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1">### your code goes here. ###</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">initialize</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="mf">1.</span><span class="n">j</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">reset</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

<span class="c1">#######</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">'mpl'</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_97_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_97_0.png"/>
</div>
</div>
<h4 style="font-size: 17px">📓Step B. Plot the 3-qubit code state produced by the above circuit, <code>qc_3qx</code> on the qsphere to validate the encoding.  </h4><p>The state displayed on the qshpere should match the 3-qubit code state for <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> upto a global phase.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### your code goes here ###</span>
<span class="n">quantum_state</span> <span class="o">=</span> <span class="n">Statevector</span><span class="p">(</span><span class="n">qc_3qx</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">quantum_state</span><span class="p">)</span>
<span class="n">plot_state_qsphere</span><span class="p">(</span><span class="n">quantum_state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Statevector([7.07106781e-01+0.j        , 0.00000000e+00+0.j        ,
             0.00000000e+00+0.j        , 0.00000000e+00+0.j        ,
             0.00000000e+00+0.j        , 0.00000000e+00+0.j        ,
             0.00000000e+00+0.j        , 1.11022302e-16+0.70710678j],
            dims=(2, 2, 2))
</pre></div>
</div>
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_100_1.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_100_1.png"/>
</div>
</div>
<h4 style="font-size: 17px">Step C. Implement the parity check gates to detect and localize a single bit flip error on the code qubits.</h4><p>Following operation will apply a single bit flip error on the code. Execute the cells below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">apply_err</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">err</span><span class="p">):</span>
    
    <span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">'Error'</span><span class="p">)</span>
    <span class="n">which_qubit</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">err</span><span class="o">==</span><span class="s1">'bit'</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">which_qubit</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">err</span><span class="o">==</span><span class="s1">'phase'</span><span class="p">:</span>
        <span class="n">qc</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">which_qubit</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    
    <span class="n">err</span> <span class="o">=</span> <span class="n">qc</span><span class="o">.</span><span class="n">to_gate</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">err</span><span class="p">,</span> <span class="n">which_qubit</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">err</span><span class="p">,</span> <span class="n">which_qubit</span> <span class="o">=</span> <span class="n">apply_err</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'bit'</span><span class="p">)</span>

<span class="n">qc_3qx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">'mpl'</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_104_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_104_0.png"/>
</div>
</div>
<p>📓 Apply the parity check gates on the circuit <code class="docutils literal notranslate"><span class="pre">qc</span></code> with the extra registers for the appropriate number of auxiliary qubits and syndrome bits to locate a bit-flip ( X ) error on a single qubit in the code. ( For 3 qubit code, the number of syndrome bit states is equal to the number of possible single bit-flip error, including no error.)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Execute this cell to add the extra registers</span>

<span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">'number of auxiliary qubits ( / syndrome bits): '</span><span class="p">))</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">'auxiliary'</span><span class="p">))</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">ClassicalRegister</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">'syndrome'</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>number of auxiliary qubits ( / syndrome bits): 2
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Apply the parity check gates and measure the parities on the syndrome bits to localize a single bit-flip ( X ) error on the code.</span>

<span class="c1">### your code goes here. ###</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc_3qx</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">######</span>

<span class="n">qc_3qx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">'mpl'</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_107_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_107_0.png"/>
</div>
</div>
<h4 style="font-size: 17px">📓Step D. Complete the dictionary in the following cell to make the syndrome look-up table for all single bit-flip errors on the three qubit code.</h4><p>The key of the dictionary is a two-bit string for the syndrome and the values reprent the corresponding a single qubit error gates with the appropriate qubit indicies on the code circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">#### complete the dictionary ###</span>

<span class="n">table_syndrome</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'00'</span><span class="p">:</span> <span class="s1">'I[0]I[1]I[2]'</span><span class="p">,</span> <span class="s1">'01'</span><span class="p">:</span><span class="s1">' X[0]I[1]I[2] '</span><span class="p">,</span> 
                  <span class="s1">'10'</span><span class="p">:</span><span class="s1">' I[0]I[1]X[2] '</span><span class="p">,</span> <span class="s1">'11'</span><span class="p">:</span><span class="s1">' I[0]X[1]I[2] '</span><span class="p">}</span>

<span class="c1">######</span>
<span class="nb">print</span><span class="p">(</span><span class="n">table_syndrome</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{'00': 'I[0]I[1]I[2]', '01': ' X[0]I[1]I[2] ', '10': ' I[0]I[1]X[2] ', '11': ' I[0]X[1]I[2] '}
</pre></div>
</div>
</div>
</div>
<p>Run the following cell to execute the circuit <code class="docutils literal notranslate"><span class="pre">qc_xerr</span></code> on <code class="docutils literal notranslate"><span class="pre">aer_simulator</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc_3qx_trans</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc_3qx</span><span class="p">,</span> <span class="n">sim</span><span class="p">)</span>
<span class="n">syndrome</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_3qx_trans</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">syndrome</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>['11']
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">📓Step E. Find the single bit-error and two bit-error based on the measured syndrome bits and check your answer with the value of the variable, <code>which_qubit</code>.</h4><p>Run the following cell.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">your_answer</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">'Enter the index of the code qubit that underwent bit-flip error: '</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">which_qubit</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">your_answer</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Enter the index of the code qubit that underwent bit-flip error: 1


True
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">Step F. Identify the logical $X$ ( $X_{L}$ ) and logical $Z$ ( $Z_{L}$ ) operators for the three qubit bit flip code.</h4><p>📓 Find the logical <span class="math notranslate nohighlight">\(X\)</span>, <span class="math notranslate nohighlight">\(X_{L}\)</span>, for three qubit bit flip code where <span class="math notranslate nohighlight">\(X_{L}|000\rangle = |111\rangle\)</span>. Construct a circuit to perform <span class="math notranslate nohighlight">\(X_{L}|0\rangle_{L}\)</span> and simulate it to check if the state produced by the circuit is <span class="math notranslate nohighlight">\(|1\rangle_{L}\)</span>, where the logical code word basis states, <span class="math notranslate nohighlight">\(|0\rangle_{L}\)</span> and <span class="math notranslate nohighlight">\(|1\rangle_{L}\)</span>, are encoded as <span class="math notranslate nohighlight">\(|0\rangle_{L} = |000\rangle, ~ |1\rangle_{L}=|111\rangle\)</span> .</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">### your code goes here ###</span>
<span class="n">qc_XL</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc_XL</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">qc_XL</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="n">bits_out</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_XL</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">bits_out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>['111']
</pre></div>
</div>
</div>
</div>
<p>📓 Find the minimal weight encoded logical <span class="math notranslate nohighlight">\(Z\)</span> ( there are four equivalent <span class="math notranslate nohighlight">\(Z_{L}\)</span>s. ) where <span class="math notranslate nohighlight">\(Z_{L}|+\rangle_{L} = |-\rangle_{L}\)</span> and <span class="math notranslate nohighlight">\(|+\rangle_{L} = |0\rangle_{L} + |1\rangle_{L}, ~~ |-\rangle_{L} = |0\rangle_{L} - |1\rangle_{L}\)</span> . What is the distance of the three qubit bit flip code? Can it detect or/and correct a single phase-flip ( Z ) error?</p>
<ul class="simple">
<li><p>weight: the weight of an operator is the number of qubits that it acts non-trivially on. ( E.g. <span class="math notranslate nohighlight">\(Z\otimes Z\otimes I\)</span> has weight 2. )</p></li>
<li><p>distance of a code: the minimum number of errors that will change one logical code word basis state to another or the maximum number of errors that can be detected.</p></li>
</ul>
<p><strong>Your answer :</strong>
The minimal weight would be 1, since a single phase-flip of any physical qubit would change the sign of the logical qubit. The code distance, for the same reason, is also 1.</p>
<h3 style="font-size: 20px">2. Construct a circuit that encodes one qubit state into 3-qubit code states and can locate a single phase-flip ( Z ) error through parity check.</h3><h4 style="font-size: 17px">📓Step A. Create a circuit to encode the state $|\psi\rangle = \frac{1}{\sqrt{2}}(|0\rangle + i|1\rangle)$ into a 3-qubit code to protect it from one phase-flip ( Z ) error.</h4><p>Here, the logical code word basis states, <span class="math notranslate nohighlight">\(|0\rangle_{L}\)</span> and <span class="math notranslate nohighlight">\(|1\rangle_{L}\)</span>, are encoded as, <span class="math notranslate nohighlight">\(|0\rangle_{L} = |+++\rangle\)</span> and <span class="math notranslate nohighlight">\(|1\rangle_{L} = |---\rangle\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc_3qz</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1">### your code goes here. ###</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">initialize</span><span class="p">([</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="mf">1.</span><span class="n">j</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">reset</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">h</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

<span class="c1">########</span>

<span class="n">qc_3qz</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">'mpl'</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_125_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_125_0.png"/>
</div>
</div>
<h4 style="font-size: 17px">📓Step B. Implement the parity check gates to detect and localize a single phase flip error on the code qubits.</h4><p>Extra registers need to be added on the circuit for the auxiliary qubits and syndrome bits.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">err</span><span class="p">,</span> <span class="n">which_qubit</span> <span class="o">=</span> <span class="n">apply_err</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s1">'phase'</span><span class="p">)</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>

<span class="c1">### your code goes here ###</span>
<span class="n">k</span><span class="o">=</span><span class="mi">2</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">'auxiliary'</span><span class="p">))</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">ClassicalRegister</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">'syndrome'</span><span class="p">))</span>

<span class="n">qc_3qz</span><span class="o">.</span><span class="n">h</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">h</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1">##########</span>
<span class="n">qc_3qz</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">'mpl'</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_128_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_128_0.png"/>
</div>
</div>
<p>Excute the cell below to run the circuit <code class="docutils literal notranslate"><span class="pre">qc_zerr</span></code> on <code class="docutils literal notranslate"><span class="pre">aer_simulator</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc_3qz_trans</span> <span class="o">=</span> <span class="n">transpile</span><span class="p">(</span><span class="n">qc_3qz</span><span class="p">,</span> <span class="n">sim</span><span class="p">)</span>
<span class="n">syndrome</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc_3qz_trans</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_memory</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">syndrome</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>['01']
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">📓Step C. Find the single phase-error based on the measured syndrome bits and check your answer with the value of the variable, <code>which_qubit</code>.</h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">your_answer</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">'Enter the index of the code qubit that underwent phase-flip error: '</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">which_qubit</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">your_answer</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Enter the index of the code qubit that underwent phase-flip error: 0


True
</pre></div>
</div>
</div>
</div>
<h2 style="font-size:24px;"> Repetition code as a stabilizer code </h2>
<br/>
<div style="background: #E8E7EB; border-radius: 5px;
-moz-border-radius: 5px;">
<p style="background: #800080;
            border-radius: 5px 5px 0px 0px;
            padding: 10px 0px 10px 10px;
            font-size:18px;
            color:white;
            "><b>Goal</b></p>
<p style=" padding: 0px 0px 10px 10px;
              font-size:16px;"> Stabilizer formalism defines Quantum Error Correcting Codes ( QECC ) by the set of operators that stabilize the logical code word states, instead of its state vectors. Interpreting quantum error correcting codes in terms of its stabilizers is beneficial since the decription of QECC is more concise and encoded logical operators can be obtained systematically. In the part 2 of this lab, we re-construct the repetition code as a stabilizer code to understand this new method.</p>
</div><h3 style="font-size: 20px">📓 1. Find the two independent stablizer operators for the 3 qubit code states, $|000\rangle,~ |111\rangle$.</h3><ul class="simple">
<li><p>The stabilizer operator <span class="math notranslate nohighlight">\(S\)</span> of a n-qubit state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> is the set of n-qubit Pauli operators that satisfy <span class="math notranslate nohighlight">\(S|\psi\rangle = |\psi\rangle\)</span>.</p></li>
</ul>
<p><strong>Your answer :</strong> <span class="math notranslate nohighlight">\(ZZI\)</span> and <span class="math notranslate nohighlight">\(IZZ\)</span></p>
<h3 style="font-size: 20px"> 2. Construct a Quantum Phase Estimation ( QPE ) circuit to produce the eigenvalues for one of the stablizer, $I\otimes Z\otimes Z$.</h3><h4 style="font-size: 17px">📓Step A. What are the eigenvalues of the operator $I\otimes Z \otimes Z$? Determine the minimum number of counting qubits needed in QPE circuit to estimate the eigenvalue accurately.</h4><p>The eigenvalues are +1 and -1.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## Your answer goes here</span>
<span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="s1">'The number of counting qubit: '</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The number of counting qubit: 1
</pre></div>
</div>
</div>
</div>
<h4 style="font-size: 17px">📓Step B. Complete the following code to build the QPE circuit. </h4><p>Note: The QPE circuit essentially performs the projective measurement of the operator <span class="math notranslate nohighlight">\(I\otimes Z\otimes Z\)</span> on the <span class="math notranslate nohighlight">\(|\psi\rangle = |0\rangle \otimes |0\rangle \otimes|+\rangle\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc0</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">qc0</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc0</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

<span class="c1">## your code goes here ##</span>
<span class="c1"># perform stabilizer</span>
<span class="n">qc0</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc0</span><span class="o">.</span><span class="n">cz</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc0</span><span class="o">.</span><span class="n">cz</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc0</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">qc0</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="c1">######</span>

<span class="n">qc0</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">qc0</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">'mpl'</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_143_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_143_0.png"/>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">counts_qc0</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc0</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">8192</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts_qc0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_144_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_144_0.png"/>
</div>
</div>
<h4 style="font-size: 17px">📓Step C. Using the circuit identities, convert QPE part of the above circuit <code>qc0</code> to the one with only CNOT gates.</h4><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qc1</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">qc1</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">qc1</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

<span class="c1">## your code goes here ##</span>
<span class="n">qc1</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc1</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

<span class="n">qc1</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
<span class="c1">######</span>

<span class="n">qc1</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">qc1</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="s1">'mpl'</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_146_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_146_0.png"/>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">counts_qc1</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">qc1</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">8192</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="n">plot_histogram</span><span class="p">(</span><span class="n">counts_qc1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/T1E2-LAB-IBM-Qiskit-Solutions_147_0.png" src="_images/T1E2-LAB-IBM-Qiskit-Solutions_147_0.png"/>
</div>
</div>
<h4 style="font-size: 17px"> Summary </h4><p>An error correcting code can be defined as an independent set of stabilizers and the errors are dectected by the measurement outcomes of this set of stabilizers.</p>
<p>Here, in part2 of this lab, we checked that there are two indepndent stabilizers for the three qubit repetition code, and measuring a stabilizer is equivalent to checking a parity. Therefore, to obtain set of syndromes for a single bit error detection with the three qubit repetition code, the circuit for encoding an arbitrary single qubit state and measuring two stabilizers has the folllowing structure.</p>
<p><img alt="image.png" src="attachment:image.png"/></p>
</div>
</div>
<script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
<script>kernelName = 'python3'</script>
</div>
<!-- Previous / next buttons -->
<div class="prev-next-area">
<a class="left-prev" href="T1E2-LAB-IBM-Qiskit.html" id="prev-link" title="previous page">
<i class="fas fa-angle-left"></i>
<div class="prev-next-info">
<p class="prev-next-subtitle">previous</p>
<p class="prev-next-title">LAB – Quantum Computing w/ Qiskit</p>
</div>
</a>
<a class="right-next" href="FINAL-PROJECTS.html" id="next-link" title="next page">
<div class="prev-next-info">
<p class="prev-next-subtitle">next</p>
<p class="prev-next-title">Final Design Project</p>
</div>
<i class="fas fa-angle-right"></i>
</a>
</div>
</div>
<html><body><div>
<div class="msger-expand">
<div class="msger-header-title">
<i class="fas fa-comment-alt"></i> ChatTutor
    </div>
<div class="msger-header-options">
<span><i class="fas fa-solid fa-caret-up"></i></span>
</div>
</div>
<div class="msger minimized">
<header class="msger-header">
<div class="msger-header-title">
<i class="fas fa-comment-alt"></i> ChatTutor
        </div>
<div class="msger-header-options">
<span><i class="fas fa-solid fa-window-minimize msger-minimize"></i></span>
</div>
</header>
<main class="msger-chat">
<div class="msg left-msg">
<div class="msg-img" style="background-image: url(https://static.thenounproject.com/png/2216285-200.png)"></div>
<div class="msg-bubble">
<div class="msg-info">
<div class="msg-info-name">ChatTutor</div>
</div>
<div class="msg-text">
            Welcome to ChatTutor, feel free to ask any questions about this lesson.
        </div>
</div>
</div>
<div class="clear-btn-container">
<button class="clear-btn">
          Clear conversation
        </button>
</div>
</main>
<form class="msger-inputarea">
<input class="msger-input" placeholder="Enter your message..." type="text"/>
<button class="msger-send-btn" type="submit">Send</button>
</form>
</div>
</div></body></html></div>
<footer class="footer">
<p>
    
      By Dirk Englund, Donnie Keathley, Jane Heyes, Kevin Chen<br/>
    
        © Copyright 2021.<br/>
</p>
</footer>
</main>
</div>
</div>
<script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<script src="_static/js/chattutor.js"></script></body>
</html>